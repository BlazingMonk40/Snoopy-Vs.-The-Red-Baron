//
// Copyright (c) Brian Hernandez. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for details.
//

using UnityEngine;
using UnityEngine.UI;
using System.Collections.Generic;
using System.Collections;

//namespace MFlight.Demo
//{
/// <summary>
/// This is a very demo-ey example of how to interpret the input generated by the
/// MouseFlightController. The plane flies towards the MouseAimPos automatically in
/// a similar fashion to how War Thunder's Instructor does it. There are also
/// keyboard overrides for flight control. It's not perfect, but it works well enough
/// for an example.
/// </summary>
[RequireComponent(typeof(Rigidbody))]
public class AIPlane : MonoBehaviour
{
    [Header("Components")]
    //[SerializeField] private MouseFlightController controller = null;
    [SerializeField] private Transform AITarget;
    [SerializeField] private NeuralNetworkFeedForward net;
    [SerializeField] private float[] aiInputs;
    [SerializeField] private float[] aiOutputs;

    [Header("Physics")]
    [Tooltip("Force to push plane forwards with")] public float thrust = 100f;
    [Tooltip("Percentage of thrust")] public float thrustPercent = 0f;
    [Tooltip("Text for Thrust Percentage")] [SerializeField] private Text thrustPercentText;
    public int intThrustText = 0;
    public bool wep;
    [Tooltip("Speed of the object.")] [SerializeField] private float speed;
    [Tooltip("Text for Speed.")] [SerializeField] private Text speedText;
    [Tooltip("Pitch, Yaw, Roll")] public Vector3 turnTorque = new Vector3(90f, 25f, 45f);
    [Tooltip("Multiplier for all forces")] public float forceMult = 1000f;

    [Header("Autopilot")]
    [Tooltip("Sensitivity for autopilot flight.")] public float sensitivity = 5f;
    [Tooltip("Angle at which airplane banks fully into target.")] public float aggressiveTurnAngle = 10f;

    [Header("Input")]
    [SerializeField] [Range(-1f, 1f)] private float pitch = 0f;
    [SerializeField] [Range(-1f, 1f)] private float yaw = 0f;
    [SerializeField] [Range(-1f, 1f)] private float roll = 0f;

    public float Pitch { set { pitch = Mathf.Clamp(value, -1f, 1f); } get { return pitch; } }
    public float Yaw { set { yaw = Mathf.Clamp(value, -1f, 1f); } get { return yaw; } }
    public float Roll { set { roll = Mathf.Clamp(value, -1f, 1f); } get { return roll; } }

    private Rigidbody rigid;

    private bool rollOverride = false;
    private bool pitchOverride = false;

    private void Awake()
    {
        rigid = GetComponent<Rigidbody>();
        
    }
    public void Init(NeuralNetworkFeedForward net, Transform AITarget)
    {
        this.net = net;
        this.AITarget = AITarget;
        
    }

    private void Update()
    {
        #region Not needed for AI
        //speed = rigid.velocity.magnitude;
        //speedText.text = $"Speed: " + speed.ToString("F0");
        ////Allows the player to adjust speed with arrow keys
        //if (Input.mouseScrollDelta.y * 0.1 > 0 && thrustPercent <= 1.2f)
        //{
        //    thrustPercent += .1f;
        //    intThrustText += 10;
        //    thrustPercentText.text = $"Thrust Percentage: " + intThrustText.ToString("F1") + "%";
        //    if (thrustPercent >= 1.1f)
        //    {
        //        thrustPercentText.text = $"Thrust Percentage: " + intThrustText.ToString("F1") + "% (WEP)";
        //        wep = true;
        //    }
        //    if (thrustPercent <= 1.0f)
        //        wep = false;
        //}
        //if (Input.mouseScrollDelta.y * 0.1 < 0 && thrustPercent >= 0f)
        //{
        //    thrustPercent -= .1f;
        //    intThrustText -= 10;
        //    thrustPercentText.text = $"Thrust Percentage: " + intThrustText.ToString("F1") + "%";
        //    if (thrustPercent >= 1.1f)
        //    {
        //        thrustPercentText.text = $"Thrust Percentage: " + intThrustText.ToString("F1") + "% (WEP)";
        //        wep = true;
        //    }
        //    if (thrustPercent <= 1.0f)
        //        wep = false;
        //}


        //// When the player commands their own stick input, it should override what the
        //// autopilot is trying to do.
        //rollOverride = false;
        //pitchOverride = false;

        //float keyboardRoll = Input.GetAxis("Horizontal");
        //if (Mathf.Abs(keyboardRoll) > .25f)
        //{
        //    rollOverride = true;
        //}

        //float keyboardPitch = Input.GetAxis("Vertical");
        //if (Mathf.Abs(keyboardPitch) > .25f)
        //{
        //    pitchOverride = true;
        //    rollOverride = true;
        //}
        #endregion
        //// Calculate the autopilot stick inputs.
        float autoYaw = 0f;
        float autoPitch = 0f;
        float autoRoll = 0f;

        RunAutopilot(AITarget.position, out autoYaw, out autoPitch, out autoRoll);

        //// Use either keyboard or autopilot input.
        //yaw = autoYaw;
        //pitch = (pitchOverride) ? keyboardPitch : autoPitch;
        //roll = (rollOverride) ? keyboardRoll : autoRoll;
        aiInputs = new float[3] { autoYaw, autoPitch, autoRoll };
        aiOutputs = net.FeedForward(aiInputs);
        float prevDistance = Vector3.Distance(transform.position, AITarget.position);
        StartCoroutine(IsCloser(prevDistance));
    }
    private IEnumerator IsCloser(float previousDist)
    {
        yield return new WaitForSeconds(.05f);
        if (Vector3.Distance(transform.position, AITarget.position) < previousDist)
            net.AddFitness(10f);
        else if (Vector3.Distance(transform.position, AITarget.position) > previousDist)
            net.AddFitness(-20f);


    }

    private void RunAutopilot(Vector3 flyTarget, out float yaw, out float pitch, out float roll)
    {
        // This is my usual trick of converting the fly to position to local space.
        // You can derive a lot of information from where the target is relative to self.
        var localFlyTarget = transform.InverseTransformPoint(flyTarget).normalized * sensitivity;
        var angleOffTarget = Vector3.Angle(transform.forward, flyTarget - transform.position);

        // IMPORTANT!
        // These inputs are created proportionally. This means it can be prone to
        // overshooting. The physics in this example are tweaked so that it's not a big
        // issue, but in something with different or more realistic physics this might
        // not be the case. Use of a PID controller for each axis is highly recommended.

        // ====================
        // PITCH AND YAW
        // ====================

        // Yaw/Pitch into the target so as to put it directly in front of the aircraft.
        // A target is directly in front the aircraft if the relative X and Y are both
        // zero. Note this does not handle for the case where the target is directly behind.
        yaw = Mathf.Clamp(localFlyTarget.x, -1f, 1f);
        pitch = -Mathf.Clamp(localFlyTarget.y, -1f, 1f);

        // ====================
        // ROLL
        // ====================

        // Roll is a little special because there are two different roll commands depending
        // on the situation. When the target is off axis, then the plane should roll into it.
        // When the target is directly in front, the plane should fly wings level.

        // An "aggressive roll" is input such that the aircraft rolls into the target so
        // that pitching up (handled above) will put the nose onto the target. This is
        // done by rolling such that the X component of the target's position is zeroed.
        var agressiveRoll = Mathf.Clamp(localFlyTarget.x, -1f, 1f);

        // A "wings level roll" is a roll commands the aircraft to fly wings level.
        // This can be done by zeroing out the Y component of the aircraft's right.
        var wingsLevelRoll = transform.right.y;

        // Blend between auto level and banking into the target.
        var wingsLevelInfluence = Mathf.InverseLerp(0f, aggressiveTurnAngle, angleOffTarget);
        roll = Mathf.Lerp(wingsLevelRoll, agressiveRoll, wingsLevelInfluence);
    }

    private void FixedUpdate()
    {
        #region idk
        //float[] aiPitch = new float[1] { pitch };
        //float[] aiYaw = new float[1] { yaw };
        //float[] aiRoll = new float[1] { roll };
        //float[] aiPitchOutput = net.FeedForward(aiPitch);
        //float[] aiYawOutput = net.FeedForward(aiYaw);
        //float[] aiRollOutput = net.FeedForward(aiRoll);
        //float activeAIPitch = aiPitchOutput[0];
        //float activeAIYaw = aiYawOutput[0];
        //float activeAIRoll = aiRollOutput[0];
        #endregion
        // Ultra simple flight where the plane just gets pushed forward and manipulated
        // with torques to turn.
        pitch = aiOutputs[0];
        yaw = aiOutputs[1];
        roll = aiOutputs[2];
        rigid.AddRelativeForce(Vector3.forward * (thrust/* * thrustPercent*/) * forceMult, ForceMode.Force);
        if (rigid.velocity.magnitude >= 10f)
        {
            rigid.AddRelativeTorque(new Vector3(turnTorque.x * pitch,
                                                turnTorque.y * yaw,
                                                -turnTorque.z * roll) * forceMult,
                                                ForceMode.Force);
        }
    }
}
//}
